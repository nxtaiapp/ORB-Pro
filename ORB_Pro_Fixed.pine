//@version=5
strategy("ORB Pro (Fixed)",
     overlay=true, initial_capital=50000,
     default_qty_type=strategy.fixed, default_qty_value=1,
     calc_on_every_tick=false,
     calc_on_order_fills=true, process_orders_on_close=false)

// ══════════════════════════════════════════════════════════════════════════════
// CONSTANTS - Centralized magic numbers and strings
// ══════════════════════════════════════════════════════════════════════════════
const string ALERT_ID = "TV_N8N_2f6e9b3c"
const int SECOND_CANDLE_LOOKBACK = 2
const int PERCENT_TO_DECIMAL = 100
const int MIN_OR_WIDTH_TICKS = 5  // NEW: Minimum valid OR width in ticks

// Alert messages
MSG_LONG_ENTRY   = "BUY: ORB signal " + ALERT_ID
MSG_SHORT_ENTRY  = "SELL: ORB signal " + ALERT_ID
MSG_TP1_LONG     = "TP1 LONG filled " + ALERT_ID
MSG_TP1_SHORT    = "TP1 SHORT filled " + ALERT_ID
MSG_RUNNER_SL    = "Runner SL filled " + ALERT_ID
MSG_FULL_TP      = "FULL TP filled " + ALERT_ID
MSG_FULL_SL      = "FULL SL filled " + ALERT_ID
MSG_VWAP_EXIT    = "EXIT: VWAP invalidation " + ALERT_ID
MSG_BREAKEVEN    = "BREAKEVEN TRIGGERED " + ALERT_ID
MSG_FLAT_4PM     = "Exit all positions at or after 4:00pm New York time"
MSG_STOP_TRADING = "STOP TRADING: Stop loss hit - done for the day " + ALERT_ID

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS - Organized by category
// ══════════════════════════════════════════════════════════════════════════════

// Opening Range & Sessions
orSession        = input.session("0930-0945", "Opening Range Window", group="Opening Range & Sessions")
orTz             = input.string("America/New_York", "OR Timezone", group="Opening Range & Sessions",
                   options=["America/New_York","UTC","America/Chicago","America/Denver","America/Los_Angeles"])
useTimeFilter    = input.bool(true, "Enable Trading Window(s)", group="Opening Range & Sessions")
amSess           = input.session("0930-1145", "AM Session", group="Opening Range & Sessions")
usePmSess        = input.bool(false, "Enable PM Session", group="Opening Range & Sessions")
pmSess           = input.session("1430-1545", "PM Session", group="Opening Range & Sessions")
sessTz           = input.string("America/New_York", "Session Timezone", group="Opening Range & Sessions",
                   options=["America/New_York","UTC","America/Chicago","America/Denver","America/Los_Angeles"])

// Confirmations
useVWAP          = input.bool(true, "Require VWAP Confirmation", group="Confirmations")
buffTicks        = input.int(2, "Breakout Buffer (ticks)", minval=0, group="Confirmations")
useEMA           = input.bool(true, "Enable EMA Filter", group="Confirmations")
emaLen           = input.int(34, "EMA Length", minval=1, group="Confirmations")
useSecondCandle  = input.bool(true, "Require 2nd-Candle Confirmation", group="Confirmations")

// HTF Trend Filter
useHTFTrend      = input.bool(true, "Enable HTF Trend Filter", group="HTF Trend Filter")
htfTimeframe     = input.timeframe("30", "HTF Timeframe", group="HTF Trend Filter")
htfEmaLen        = input.int(100, "HTF EMA Length", minval=1, group="HTF Trend Filter")
requireHTFClosed = input.bool(true, "Only trade when HTF bar is CLOSED", group="HTF Trend Filter")

// ATR / Volatility Filters
useATRFilter     = input.bool(true, "Enable Min OR vs ATR", group="ATR / Volatility Filters")
atrLen           = input.int(14, "ATR Length", minval=1, group="ATR / Volatility Filters")
atrMinFrac       = input.float(0.5, "Min OR Width = ATR ×", minval=0.1, step=0.1, group="ATR / Volatility Filters")
useATRMax        = input.bool(true, "Skip if OR too wide", group="ATR / Volatility Filters")
atrMaxFrac       = input.float(1.5, "Max OR Width = ATR ×", minval=0.5, step=0.1, group="ATR / Volatility Filters")
useLowVolSkip    = input.bool(false, "Skip if Today ATR < Yesterday ATR × K", group="ATR / Volatility Filters")
lowVolK          = input.float(0.7, "Low Vol K", minval=0.1, step=0.05, group="ATR / Volatility Filters")

// VWAP Slope
useVwapSlope     = input.bool(false, "Require VWAP Slope (anti-chop)", group="VWAP Slope")
vwapSlopeLen     = input.int(20, "Slope Lookback (bars)", minval=1, group="VWAP Slope")
vwapSlopePctMin  = input.float(0.02, "Min |Slope| (% of price)", step=0.005, group="VWAP Slope")

// Daily Context Filters
useInsideDaySkip = input.bool(false, "Skip Inside Day (vs prior day)", group="Daily Context Filters")

// Stops / Targets / Partials
tpPctInput       = input.float(100, "Base TP % of OR", minval=1, step=1, group="Stops / Targets / Partials")
slPctInput       = input.float(50, "Base SL % of OR", minval=0.1, step=0.1, group="Stops / Targets / Partials")
usePartials      = input.bool(true, "Use Partial Take Profit + Runner", group="Stops / Targets / Partials")
tp1_R            = input.float(1.0, "TP1 at R-multiple", step=0.25, group="Stops / Targets / Partials")
tp1_qty_pct      = input.int(50, "TP1 Qty %", minval=1, maxval=99, group="Stops / Targets / Partials")
useTrailingStop  = input.bool(true, "Enable Trailing Stop for Runner", group="Stops / Targets / Partials")
runnerTrailATR   = input.float(1.5, "Runner ATR Trail (× ATR)", step=0.1, group="Stops / Targets / Partials")
trailActivate_R  = input.float(0.75, "Activate Runner Trail at R", step=0.25, group="Stops / Targets / Partials")

// Breakeven / Risk Caps
useBreakeven     = input.bool(true, "Enable Breakeven Stop (one-time)", group="Breakeven / Risk Caps")
bePctInput       = input.float(75, "BE Trigger % of OR", minval=1, step=1, group="Breakeven / Risk Caps")
maxLossDollars   = input.float(0, "Max Loss per Trade ($)", minval=0, step=1, group="Breakeven / Risk Caps")
stopOnSL         = input.bool(true, "Stop Trading After Stop Loss Hit", group="Breakeven / Risk Caps")

// Misc
enableAlerts     = input.bool(true, "Enable Alerts", group="Misc")

// Backtest range: allow auto last-N-days (default) or manual start/end
backtestAuto     = input.bool(true, "Auto backtest last N days", group="Backtest")
backtestDays     = input.int(30, "Backtest Days (N)", minval=1, group="Backtest")
backtestStart    = input.time(timestamp("2020-01-01T00:00"), "Backtest Start (manual)", group="Backtest")
backtestEnd      = input.time(timestamp("2030-12-31T23:59"), "Backtest End (manual)", group="Backtest")

// Convert percentages to decimals
buff          = buffTicks * syminfo.mintick
useBuffer     = buffTicks > 0
tpPct         = tpPctInput / PERCENT_TO_DECIMAL
slPct         = slPctInput / PERCENT_TO_DECIMAL
bePctOfOR     = bePctInput / PERCENT_TO_DECIMAL

// ══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS - Reduce code duplication
// ══════════════════════════════════════════════════════════════════════════════

// Calculate stop loss with max loss override
calcStopLoss(float rawStop, float entryPrice, bool isLong) =>
    if maxLossDollars <= 0
        rawStop
    else
        maxLossPts = maxLossDollars / syminfo.pointvalue
        riskPts = isLong ? (entryPrice - rawStop) : (rawStop - entryPrice)
        if riskPts > maxLossPts
            isLong ? (entryPrice - maxLossPts) : (entryPrice + maxLossPts)
        else
            rawStop

// Check if entry price is valid (not beyond TP or past SL)
isEntryValid(float entryPrice, float tpLevel, float slLevel, bool isLong) =>
    tpOk = na(tpLevel) or (isLong ? entryPrice < tpLevel : entryPrice > tpLevel)
    slOk = na(slLevel) or (isLong ? entryPrice > slLevel : entryPrice < slLevel)
    tpOk and slOk


// ══════════════════════════════════════════════════════════════════════════════
// OPENING RANGE & SESSIONS
// ══════════════════════════════════════════════════════════════════════════════
inOr    = not na(time(timeframe.period, orSession, orTz))
orStart = inOr and not inOr[1]

var float orHigh = na
var float orLow  = na

if orStart
    orHigh := high
    orLow  := low
else if inOr
    orHigh := math.max(orHigh, high)
    orLow  := math.min(orLow, low)

orMid   = (orHigh + orLow) / 2
orWidth = orHigh - orLow

// FIXED: Minimum OR width validation (at least 5 ticks)
minOrWidth = MIN_OR_WIDTH_TICKS * syminfo.mintick
haveOR  = not na(orHigh) and not na(orLow) and orWidth >= minOrWidth
R       = haveOR ? orWidth : na  // R = effective OR width

// Session windows
inAM     = not useTimeFilter or not na(time(timeframe.period, amSess, sessTz))
inPM     = usePmSess and not na(time(timeframe.period, pmSess, sessTz))
inWindow = (not useTimeFilter) or inAM or inPM

// FIXED: Backtest range logic - clarified auto mode behavior
// In auto mode, test on all bars but only include last N days of data
msPerDay = 24 * 60 * 60 * 1000
var int backtestStartTime = na

// Calculate backtest start once at beginning of chart
if na(backtestStartTime) and backtestAuto
    backtestStartTime := timenow - backtestDays * msPerDay

// Determine effective range
startEffective = backtestAuto ? backtestStartTime : backtestStart
endEffective = backtestAuto ? timenow : backtestEnd
inBacktestRange = time >= startEffective and time <= endEffective

// NEW: Stop trading after stop loss tracking
var bool stopLossHitToday = false
var int lastSLDay = 0

// Detect new trading day and reset flag
newDay = ta.change(dayofweek) != 0 or (bar_index == 0)
if newDay
    stopLossHitToday := false
    lastSLDay := dayofmonth

// ══════════════════════════════════════════════════════════════════════════════
// INDICATORS
// ══════════════════════════════════════════════════════════════════════════════
vwap = ta.vwap(hlc3)
ema  = ta.ema(close, emaLen)
atr  = ta.atr(atrLen)

// FIXED: HTF indicators with proper closed bar detection
// Request HTF time to detect when HTF bar actually changes
htfEMA = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, htfEmaLen), barmerge.gaps_off, barmerge.lookahead_off)
htfTime = request.security(syminfo.tickerid, htfTimeframe, time, barmerge.gaps_off, barmerge.lookahead_off)
htfTimeChanged = ta.change(htfTime) != 0  // HTF bar just closed
var bool htfBarClosed = false

// Track HTF bar state: once it closes, stay closed until next chart bar
if htfTimeChanged
    htfBarClosed := true
else if strategy.position_size != strategy.position_size[1]
    htfBarClosed := false  // Reset after entry signal

// Daily data (consolidated requests)
[dailyHigh_prev, dailyLow_prev, dailyATR_curr, dailyATR_prev] = request.security(syminfo.tickerid, "D", [high[1], low[1], ta.atr(14), ta.atr(14)[1]], barmerge.gaps_off, barmerge.lookahead_off)

// ══════════════════════════════════════════════════════════════════════════════
// FILTER CONDITIONS - Named booleans for clarity
// ══════════════════════════════════════════════════════════════════════════════

// VWAP Slope filter
vwapSlopeOk = true
if useVwapSlope
    vwapSlope = vwap - nz(vwap[vwapSlopeLen])
    vwapSlopePct = math.abs(vwapSlope) / close * PERCENT_TO_DECIMAL
    vwapSlopeOk := vwapSlopePct >= vwapSlopePctMin

// Inside day filter
insideDayOk = true
if useInsideDaySkip and haveOR
    isInside = (orHigh < dailyHigh_prev) and (orLow > dailyLow_prev)
    insideDayOk := not isInside

// Low volatility filter
lowVolOk = not useLowVolSkip or dailyATR_curr >= dailyATR_prev * lowVolK

// OR width validation
orWidthOk = true
if useATRFilter
    orWidthOk := orWidth >= atr * atrMinFrac
if useATRMax
    orWidthOk := orWidthOk and orWidth <= atr * atrMaxFrac

validOR = haveOR and orWidthOk

// FIXED: HTF trend gate with proper closed bar detection
htfGate    = not useHTFTrend or (not requireHTFClosed or htfBarClosed)
htfLongOk  = not useHTFTrend or (htfGate and close > htfEMA)
htfShortOk = not useHTFTrend or (htfGate and close < htfEMA)

// Build common filter set for long/short to reduce duplication
filterParams(bool isLong) =>
    htfOk = isLong ? htfLongOk : htfShortOk
    vwapOk = not useVWAP or (isLong ? close > vwap : close < vwap)
    bufferOk = not useBuffer or (isLong ? close > orHigh + buff : close < orLow - buff)
    emaOk = not useEMA or (isLong ? close > ema : close < ema)
    htfOk and vwapOk and bufferOk and emaOk

// Simplified second-candle confirmation with clear guards
secondCandleOk(bool isLong) =>
    if not useSecondCandle
        true
    else if bar_index <= SECOND_CANDLE_LOOKBACK
        false
    else
        // require OR existed on previous bars and the immediate prior bar is the confirming candle
        prevExists = haveOR[1] and haveOR[2]
        if not prevExists or inOr[1]
            false
        else
            isLong ? (close[1] > orHigh[1] and close[2] <= orHigh[2]) : (close[1] < orLow[1] and close[2] >= orLow[2])


// ══════════════════════════════════════════════════════════════════════════════
// STOP LOSS & TAKE PROFIT LEVELS
// ══════════════════════════════════════════════════════════════════════════════
var float tpLong  = na
var float tpShort = na
var float slLong  = na
var float slShort = na

if orStart
    tpLong  := na
    tpShort := na
    slLong  := na
    slShort := na

if haveOR
    // Base TP/SL levels
    tpLong_raw  = orHigh + R * tpPct
    tpShort_raw = orLow  - R * tpPct
    slLong_raw  = orHigh - R * slPct
    slShort_raw = orLow  + R * slPct

    // Store base levels (max loss will be applied in exit orders if needed)
    tpLong  := tpLong_raw
    tpShort := tpShort_raw
    slLong  := slLong_raw
    slShort := slShort_raw

// ══════════════════════════════════════════════════════════════════════════════
// BREAKOUT CONDITIONS
// ══════════════════════════════════════════════════════════════════════════════
longBreakout  = haveOR and not inOr and high > orHigh
shortBreakout = haveOR and not inOr and low < orLow

// Second-candle confirmation implemented via centralized helper `secondCandleOk` above

// Entry validity
entryValidLong  = isEntryValid(close, tpLong, slLong, true)
entryValidShort = isEntryValid(close, tpShort, slShort, false)

// Directional filters (use centralized helper)
longFiltersOk = filterParams(true)
shortFiltersOk = filterParams(false)

// ══════════════════════════════════════════════════════════════════════════════
// FINAL SIGNALS
// ══════════════════════════════════════════════════════════════════════════════
// NEW: Allow trading only if stop loss hasn't been hit today (when enabled)
allowTrading = not stopOnSL or not stopLossHitToday

longSignal = longBreakout and validOR and longFiltersOk and vwapSlopeOk and
             inWindow and inBacktestRange and secondCandleOk(true) and entryValidLong and
             insideDayOk and lowVolOk and allowTrading

shortSignal = shortBreakout and validOR and shortFiltersOk and vwapSlopeOk and
              inWindow and inBacktestRange and secondCandleOk(false) and entryValidShort and
              insideDayOk and lowVolOk and allowTrading

// ══════════════════════════════════════════════════════════════════════════════
// ENTRIES
// ══════════════════════════════════════════════════════════════════════════════
if longSignal and strategy.position_size <= 0
    strategy.entry("Long", strategy.long, alert_message=MSG_LONG_ENTRY)

if shortSignal and strategy.position_size >= 0
    strategy.entry("Short", strategy.short, alert_message=MSG_SHORT_ENTRY)

// ══════════════════════════════════════════════════════════════════════════════
// BREAKEVEN MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════
var bool beTriggered = false

if strategy.position_size == 0
    beTriggered := false

beDist = haveOR ? R * bePctOfOR : na

longBeHit  = useBreakeven and not beTriggered and strategy.position_size > 0 and
             not na(beDist) and high >= strategy.position_avg_price + beDist
shortBeHit = useBreakeven and not beTriggered and strategy.position_size < 0 and
             not na(beDist) and low <= strategy.position_avg_price - beDist

if longBeHit or shortBeHit
    beTriggered := true
    if enableAlerts
        alert(MSG_BREAKEVEN, alert.freq_once_per_bar_close)

// Active stops (BE or original, with max loss applied if configured)
activeLongStop  = beTriggered and strategy.position_size > 0 ?
                  strategy.position_avg_price :
                  calcStopLoss(slLong, strategy.position_avg_price, true)

activeShortStop = beTriggered and strategy.position_size < 0 ?
                  strategy.position_avg_price :
                  calcStopLoss(slShort, strategy.position_avg_price, false)

// Use appropriate stop based on position status
beStopLong  = strategy.position_size > 0 ? activeLongStop : slLong
beStopShort = strategy.position_size < 0 ? activeShortStop : slShort

// ══════════════════════════════════════════════════════════════════════════════
// EXITS - FIXED trailing stop implementation
// ══════════════════════════════════════════════════════════════════════════════
trailOffset = atr * runnerTrailATR

// Runner activation
longTrailActive  = strategy.position_size > 0 and haveOR and
                   high >= strategy.position_avg_price + trailActivate_R * R
shortTrailActive = strategy.position_size < 0 and haveOR and
                   low <= strategy.position_avg_price - trailActivate_R * R

// Partial TP levels
longTp1  = haveOR ? strategy.position_avg_price + tp1_R * R : na
shortTp1 = haveOR ? strategy.position_avg_price - tp1_R * R : na

// Build exit params for DRY exit placement (defined after BE and trail vars)
buildExitParams(bool isLong) =>
    baseTP = isLong ? tpLong : tpShort
    baseSL = isLong ? slLong : slShort
    beStop = isLong ? beStopLong : beStopShort
    tp1 = isLong ? longTp1 : shortTp1
    runnerActive = isLong ? longTrailActive : shortTrailActive
    [baseTP, baseSL, beStop, tp1, runnerActive]

// FIXED: Place exits with proper trail_points instead of trail_price
placeExitsFor(string entryId, bool isLong) =>
    [baseTP, baseSL, beStop, tp1, runnerActive] = buildExitParams(isLong)

    // Convert trail offset to points (ticks)
    trailPoints = trailOffset / syminfo.mintick

    if usePartials
        // First exit: TP1 with stop at beStop
        strategy.exit(entryId + "-TP1", entryId, limit=tp1, stop=beStop,
                      qty_percent=tp1_qty_pct, comment="TP1/SL",
                      alert_message=(isLong ? MSG_TP1_LONG : MSG_TP1_SHORT))

        // Runner exit: Trail if enabled and active, otherwise fixed stop
        if useTrailingStop and runnerActive
            // Use trail_points for proper trailing behavior
            strategy.exit(entryId + "-Run", entryId, trail_points=trailPoints, stop=beStop,
                          qty_percent=100 - tp1_qty_pct, comment="Trail SL", alert_message=MSG_RUNNER_SL)
        else
            // Fixed stop (either trailing disabled or not yet activated)
            strategy.exit(entryId + "-Run", entryId, limit=baseTP, stop=beStop,
                          qty_percent=100 - tp1_qty_pct, comment="SL/TP", alert_message=MSG_RUNNER_SL)
    else
        // Full position exit
        strategy.exit(entryId + "-Exit", entryId, limit=baseTP, stop=(useBreakeven ? beStop : baseSL),
                      comment="TP/SL", alert_message=MSG_FULL_TP)

// Place exits based on position (use centralized helper)
if strategy.position_size > 0
    placeExitsFor("Long", true)
else if strategy.position_size < 0
    placeExitsFor("Short", false)

// If user provided a manual end date, force-close positions once we're past it
if not backtestAuto and time > endEffective and strategy.position_size != 0
    strategy.close_all(comment="Backtest range end")

// VWAP invalidation
longInvalidVWAP  = useVWAP and strategy.position_size > 0 and ta.crossunder(close, vwap)
shortInvalidVWAP = useVWAP and strategy.position_size < 0 and ta.crossover(close, vwap)

if longInvalidVWAP
    strategy.close("Long", comment="VWAP Invalidate", alert_message=MSG_VWAP_EXIT)
    if enableAlerts
        alert(MSG_VWAP_EXIT, alert.freq_once_per_bar_close)

if shortInvalidVWAP
    strategy.close("Short", comment="VWAP Invalidate", alert_message=MSG_VWAP_EXIT)
    if enableAlerts
        alert(MSG_VWAP_EXIT, alert.freq_once_per_bar_close)

alertcondition(longInvalidVWAP or shortInvalidVWAP, title="VWAP Invalidate", message=MSG_VWAP_EXIT)

// Daily 4pm flat
after4pmNY = not na(time(timeframe.period, "1600-2359", "America/New_York"))
flat4pm    = strategy.position_size != 0 and after4pmNY

if flat4pm
    strategy.close_all(comment="Flat 4pm NY", alert_message=MSG_FLAT_4PM)
    if enableAlerts
        alert(MSG_FLAT_4PM, alert.freq_once_per_bar_close)

alertcondition(flat4pm, title="Daily Flat 4pm NY", message=MSG_FLAT_4PM)

// NEW: Detect stop loss hits and stop trading for the day
tradeJustClosed = strategy.closedtrades > 0 and strategy.closedtrades != strategy.closedtrades[1]

if stopOnSL and tradeJustClosed
    lastTradeIndex = strategy.closedtrades - 1
    exitPrice = strategy.closedtrades.exit_price(lastTradeIndex)
    entryPrice = strategy.closedtrades.entry_price(lastTradeIndex)
    wasLong = strategy.closedtrades.entry_id(lastTradeIndex) == "Long"

    // Determine if this was a stop loss (losing trade)
    hitSL = wasLong ? (exitPrice < entryPrice) : (exitPrice > entryPrice)

    if hitSL and not stopLossHitToday
        stopLossHitToday := true
        if enableAlerts
            alert(MSG_STOP_TRADING, alert.freq_once_per_bar_close)

alertcondition(stopLossHitToday, title="Stop Trading - SL Hit", message=MSG_STOP_TRADING)

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL ELEMENTS
// ══════════════════════════════════════════════════════════════════════════════

// Plot OR levels and indicators
plot(orHigh, "OR High", color=color.gray, linewidth=1)
plot(orLow, "OR Low", color=color.gray, linewidth=1)
plot(orMid, "OR Mid", color=color.silver, linewidth=1)
plot(useVWAP ? vwap : na, "VWAP", color=color.yellow, linewidth=2)
plot(useEMA ? ema : na, "EMA", color=color.blue, linewidth=2)
plot(useHTFTrend ? htfEMA : na, "HTF EMA", color=color.purple, linewidth=2, style=plot.style_linebr)

// Plot stop levels
plot(haveOR ? slLong : na, "SL Long", color=color.new(color.red, 0), style=plot.style_linebr)
plot(haveOR ? slShort : na, "SL Short", color=color.new(color.red, 0), style=plot.style_linebr)

// NEW: Plot take profit levels when in position
plotTpLong = strategy.position_size > 0 and not na(tpLong) ? tpLong : na
plotTpShort = strategy.position_size < 0 and not na(tpShort) ? tpShort : na
plot(plotTpLong, "TP Long", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(plotTpShort, "TP Short", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)

// NEW: Plot TP1 (partial take profit) levels when in position
plotTp1Long = strategy.position_size > 0 and usePartials and not na(longTp1) ? longTp1 : na
plotTp1Short = strategy.position_size < 0 and usePartials and not na(shortTp1) ? shortTp1 : na
plot(plotTp1Long, "TP1 Long", color=color.new(color.lime, 0), style=plot.style_circles, linewidth=1)
plot(plotTp1Short, "TP1 Short", color=color.new(color.lime, 0), style=plot.style_circles, linewidth=1)

// NEW: Plot active stop loss (includes breakeven) when in position
plotActiveSlLong = strategy.position_size > 0 and not na(beStopLong) ? beStopLong : na
plotActiveSlShort = strategy.position_size < 0 and not na(beStopShort) ? beStopShort : na
plot(plotActiveSlLong, "Active SL Long", color=color.new(color.red, 30), style=plot.style_linebr, linewidth=2)
plot(plotActiveSlShort, "Active SL Short", color=color.new(color.red, 30), style=plot.style_linebr, linewidth=2)

// NEW: Plot trailing stop when active (only if trailing stop is enabled)
var float trailStopLong = na
var float trailStopShort = na

// Calculate trailing stop level only if trailing stop is enabled
if useTrailingStop and strategy.position_size > 0 and longTrailActive
    trailStopLong := high - trailOffset
    if na(trailStopLong[1])
        trailStopLong := high - trailOffset
    else
        trailStopLong := math.max(trailStopLong[1], high - trailOffset)
else if strategy.position_size <= 0
    trailStopLong := na

if useTrailingStop and strategy.position_size < 0 and shortTrailActive
    trailStopShort := low + trailOffset
    if na(trailStopShort[1])
        trailStopShort := low + trailOffset
    else
        trailStopShort := math.min(trailStopShort[1], low + trailOffset)
else if strategy.position_size >= 0
    trailStopShort := na

plot(trailStopLong, "Trail Stop Long", color=color.new(color.orange, 0), style=plot.style_linebr, linewidth=2)
plot(trailStopShort, "Trail Stop Short", color=color.new(color.orange, 0), style=plot.style_linebr, linewidth=2)

// Background for closed trading windows
bgcolor(useTimeFilter and not inWindow ? color.new(color.red, 85) : na)

// NEW: Background for stopped trading (stop loss hit)
bgcolor(stopOnSL and stopLossHitToday ? color.new(color.orange, 90) : na, title="Trading Stopped")

// TP/SL exit labels
// Note: tradeJustClosed already defined above for stop loss detection

var bool showTP = false
var bool showSL = false

if tradeJustClosed
    lastTradeIndex = strategy.closedtrades - 1
    exitPrice = strategy.closedtrades.exit_price(lastTradeIndex)
    entryPrice = strategy.closedtrades.entry_price(lastTradeIndex)
    wasLong = strategy.closedtrades.entry_id(lastTradeIndex) == "Long"

    hitTP = wasLong ? (exitPrice > entryPrice) : (exitPrice < entryPrice)

    showTP := hitTP
    showSL := not hitTP
else
    showTP := false
    showSL := false

plotshape(showTP, "TP", style=shape.labelup, location=location.belowbar,
          color=color.new(color.green, 0), text="TP", textcolor=color.white, size=size.tiny)
plotshape(showSL, "SL", style=shape.labeldown, location=location.abovebar,
          color=color.new(color.red, 0), text="SL", textcolor=color.white, size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// KNOWN LIMITATIONS & NOTES
// ══════════════════════════════════════════════════════════════════════════════
// 1. Trailing stop uses trail_points - behavior is consistent in backtest and real-time
// 2. HTF bar closed detection tracks time changes - may have 1-bar lag on timeframe boundaries
// 3. Second candle confirmation requires 2+ bars of history - no signals on first 2 bars
// 4. VWAP invalidation closes entire position - partials not preserved
// 5. Max loss override adjusts SL but doesn't reduce position size
// 6. Minimum OR width set to 5 ticks - adjust MIN_OR_WIDTH_TICKS constant if needed
// 7. Stop trading after SL feature blocks ALL entries after first losing trade of the day
//    - Resets at day change (detected by dayofweek change)
//    - Orange background indicates trading is stopped for the day
//    - Can be disabled via "Stop Trading After Stop Loss Hit" input
// 8. Visual indicators show live position levels:
//    - Green solid line: Full TP target
//    - Lime circles: TP1 (partial) target
//    - Red translucent line: Active stop loss (includes breakeven)
//    - Orange line: Trailing stop (when activated and enabled)
// 9. Trailing stop can be disabled via "Enable Trailing Stop for Runner" input
//    - When disabled, runner uses fixed TP target instead of trailing
//    - Useful for testing strategy with/without trailing behavior
